import pandas as pd
import numpy as np
from typing import List, Tuple
from .app_basic import FrameInfo, AEFrameInfo, PacketInfo, PacketBuffer

class FrameBuffer:
    """
    a buffer maintaining the frame send/recv status
    also provide the final PSNR v.s. latency calculation
    """
    def __init__(self):
        self.frames = {} # List[FrameInfo]

    def on_frame_sent(self, ts: float, frame: FrameInfo):
        """
        Note: it will call frame.on_sent(), so do not call it outside this class
        Input:
            ts: the timestamp of the frame being sent
            frame: the frame itself
            psnr: the psnr of that frame
        """
        fid = frame.frame_id
        if fid in self.frames:
            raise RuntimeError(f"Two frames share the same frame id {fid}")
        frame.on_sent(ts)
        self.frames[fid] = frame

    def on_packet_received(self, ts: float, pkt: PacketInfo):
        """
        Called when a packet is received
        ts: the timestamp when packet is received
        pkt: the packet
        """
        frame_id, frag_id = FrameInfo.TranslatePacketId(pkt.id)
        if frame_id not in self.frames:
            print(f"\033[33mWarning: Frame {frame_id} is not found in the frame buffer, skip!\033[0m")
            return
        self.frames[frame_id].on_recv(ts, pkt)

    def get_frames(self) -> List[FrameInfo]:
        return list(self.frames.values())

    def get_psnr_delay(self, skip_bad = True)-> pd.DataFrame:
        """
        Returns the psnr and delay in a DataFrame format
        The frame who are not received is skipped if skip_bad=True
        """
        data = [] # format <frame_id> <psnr> <delay> <size>
        for frame_id in self.frames.keys():
            frame = self.frames[frame_id]
            psnr = frame.get_psnr()
            delay = frame.get_delay()
            size = frame.size
            if skip_bad and delay is None:
                continue
            data.append((frame_id, psnr, delay, size))

        ret = pd.DataFrame(data, columns=["frame_id", "psnr", "delay", "size"])
        return ret

class SimpleSender:
    """
    Do not do any FEC or retransmission
    """
    def __init__(self, frame_rate: int):
        self.frame_buffer = FrameBuffer()
        self.pkt_buffer = PacketBuffer()
        self.target_bitrate_kbps = 100 # bitrate in KB per sec
        self.frame_rate = frame_rate 

    def on_new_frame(self, ts:float, frame: FrameInfo):
        """
        Called when a new frame generated by the encoder
        Packetize the new frame and update internal packet mapping
        Input:
            frame: the frame info object
        """
        self.frame_buffer.on_frame_sent(ts, frame)
        pkts = frame.packetize()
        for pkt in pkts:
            self.pkt_buffer.add_packet(pkt)
    
    def on_packet_feedback(self, ts: float, pkt_id: int, is_lost: bool, delay: float, recv_ts: float, size: int):
        """
        Called when a packet feedback is received
        Update the internal frame buffer status and handle retransmissions
        Input:
            ts: current timestamp
            pkt_id: the id of the received packet feedback
            is_lost: is the packet lost or not
            delay: the one-way-delay of the packet (sender->receiver)
            recv_ts: the time when packet is received
            size: the size of the packet in bytes
        """
        pkt = PacketInfo(pkt_id, size) 
        if not is_lost:
            self.frame_buffer.on_packet_received(recv_ts, pkt)
        else:
            print(" === Packet {} is lost! skip!".format(pkt.id))

    def on_target_bitrate_change(self, bitrate_byte_sec: int):
        """
        Called when target bitrate changes
        Input:
            target_bitrate: target bitrate in byte per sec
        """
        self.target_bitrate_kbps = bitrate_byte_sec / 1000 # convert to KB per sec

    def calculate_frame_size(self, interval: float) -> int:
        """
        Called when about to encode a new frame, returns a suitable size for the next frame in BYTES
        Input:
            interval: the interval between frames, in seconds
        Returns:
            the frame size in bytes
        """
        return self.target_bitrate_kbps * 1000 * interval

    def has_data(self, ts: float) -> bool:
        """
        ts: the current timestamp
        returns True if there is any data to send
        """
        return self.pkt_buffer.has_data() 

    def queue_len(self, ts: float) -> int:
        return self.pkt_buffer.queue_len() 

    def get_packet(self) -> Tuple[int, int]:
        """
        returns packet id and size
        if no packets, return None, None
        """
        if self.pkt_buffer.has_data():
            pkt = self.pkt_buffer.get_packet()
            return pkt.id, pkt.size

        print("\033[33m Warning: called get_packet() but there is no packet in the buffer \033[0m")
        return None, None

    def get_frame_buffer(self) -> FrameBuffer:
        """
        Returns the frame_buffer in the implementation
        """
        return self.frame_buffer

class NACKSender(SimpleSender):
    """
    NACK transmission control, no extra traffic, using NACK for retransmission
    """
    def __init__(self, frame_rate: int):
        super(NACKSender, self).__init__(frame_rate)
        self.rtx_buffer = PacketBuffer()

    def on_packet_feedback(self, ts: float, pkt_id: int, is_lost: bool, delay: float, recv_ts: float, size: int):
        """
        Called when a packet feedback is received
        Update the internal frame buffer status and handle retransmissions
        Input:
            ts: current timestamp
            pkt_id: the id of the received packet feedback
            is_lost: is the packet lost or not
            delay: the one-way-delay of the packet (sender->receiver)
            recv_ts: the time when packet is received
            size: the size of the packet in bytes
        """
        # TODO: HERE: the RTX traffic will make the link status even worse!
        #             we need to find some way to remove RTX overhead when getting the size of next frame
        pkt = PacketInfo(pkt_id, size) 
        if is_lost:
            print("\033[33m[{:.4f}] enqueue an RTX packet for packet id = {}\033[0m".format(ts, pkt_id))
            self.rtx_buffer.add_packet(pkt)
        else:
            ''' add the packet into the frame buffer '''
            self.frame_buffer.on_packet_received(recv_ts, pkt)

    def has_data(self, ts: float) -> bool:
        """
        ts: the current timestamp
        returns True if there is any data to send
        """
        return self.pkt_buffer.has_data() or self.rtx_buffer.has_data()

    def queue_len(self, ts: float) -> int:
        return self.pkt_buffer.queue_len() + self.rtx_buffer.queue_len()

    def get_packet(self) -> Tuple[int, int]:
        """
        returns packet id and size
        if no packets, return None, None
        """
        if self.rtx_buffer.has_data():
            pkt = self.rtx_buffer.get_packet()
            return pkt.id, pkt.size
        if self.pkt_buffer.has_data():
            pkt = self.pkt_buffer.get_packet()
            return pkt.id, pkt.size

        print("\033[33m Warning: called get_packet() but there is no packet in the buffer \033[0m")
        return None, None
    
